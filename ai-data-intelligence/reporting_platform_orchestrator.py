"""
AI-Driven Reporting Platform - Autonomous Report Generation System

This platform creates intelligent reporting agents that can:
- Automatically generate business reports
- Create dynamic dashboards and visualizations
- Schedule and distribute reports
- Provide natural language insights
- Generate executive summaries
- Create predictive business forecasts

Revolutionary Features:
- Natural language report generation
- Auto-scheduling and distribution
- Interactive dashboard creation
- Cross-platform report delivery
- Real-time insight updates
- Custom report templates
"""

import asyncio
import json
import logging
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from pathlib import Path
from enum import Enum
import sqlite3

# Import data intelligence orchestrator
from data_intelligence_orchestrator import data_intelligence, DataInsight, Report

# Additional imports for advanced reporting
try:
    import plotly.graph_objects as go
    import plotly.express as px
    from plotly.subplots import make_subplots
    import plotly.io as pio
    PLOTLY_AVAILABLE = True
except ImportError:
    PLOTLY_AVAILABLE = False

try:
    import pandas as pd
    import numpy as np
    PANDAS_AVAILABLE = True
except ImportError:
    PANDAS_AVAILABLE = False

try:
    import jinja2
    JINJA2_AVAILABLE = True
except ImportError:
    JINJA2_AVAILABLE = False

class ReportFormat(Enum):
    """Report output formats"""
    HTML = "html"
    PDF = "pdf" 
    JSON = "json"
    EXCEL = "excel"
    POWERPOINT = "powerpoint"
    MARKDOWN = "markdown"

class ReportFrequency(Enum):
    """Report generation frequency"""
    REAL_TIME = "real_time"
    HOURLY = "hourly"
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    QUARTERLY = "quarterly"

class ReportPriority(Enum):
    """Report priority levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

@dataclass
class ReportTemplate:
    """Report template configuration"""
    id: str
    name: str
    description: str
    sections: List[str]
    data_sources: List[str]
    analysis_types: List[str]
    format: ReportFormat
    frequency: ReportFrequency
    recipients: List[str]
    created_at: str
    active: bool = True

@dataclass
class ReportSchedule:
    """Report scheduling configuration"""
    id: str
    template_id: str
    frequency: ReportFrequency
    next_run: str
    last_run: Optional[str]
    recipients: List[str]
    delivery_methods: List[str]
    active: bool = True

@dataclass
class ExecutiveSummary:
    """Executive summary generated by AI"""
    title: str
    key_findings: List[str]
    critical_issues: List[str]
    recommendations: List[str]
    business_impact: str
    confidence_score: float
    generated_at: str

@dataclass
class DashboardWidget:
    """Dashboard widget configuration"""
    id: str
    title: str
    type: str  # chart, metric, table, text
    data_source: str
    config: Dict[str, Any]
    position: Dict[str, int]  # x, y, width, height
    refresh_interval: int  # seconds

class AIReportingOrchestrator:
    """Central orchestrator for AI-driven reporting"""
    
    def __init__(self):
        self.logger = logging.getLogger("ai_reporting")
        self.templates: Dict[str, ReportTemplate] = {}
        self.schedules: Dict[str, ReportSchedule] = {}
        self.dashboard_widgets: Dict[str, DashboardWidget] = {}
        self.generated_reports: Dict[str, Report] = {}
        
        # Initialize components
        self._initialize_database()
        self._load_default_templates()
        self._initialize_report_engine()
    
    def _initialize_database(self):
        """Initialize the reporting database"""
        try:
            self.db_path = "ai_reporting.db"
            conn = sqlite3.connect(self.db_path)
            
            # Create tables
            conn.execute("""
                CREATE TABLE IF NOT EXISTS report_templates (
                    id TEXT PRIMARY KEY,
                    name TEXT,
                    description TEXT,
                    sections TEXT,
                    data_sources TEXT,
                    analysis_types TEXT,
                    format TEXT,
                    frequency TEXT,
                    recipients TEXT,
                    created_at TEXT,
                    active BOOLEAN
                )
            """)
            
            conn.execute("""
                CREATE TABLE IF NOT EXISTS report_schedules (
                    id TEXT PRIMARY KEY,
                    template_id TEXT,
                    frequency TEXT,
                    next_run TEXT,
                    last_run TEXT,
                    recipients TEXT,
                    delivery_methods TEXT,
                    active BOOLEAN
                )
            """)
            
            conn.execute("""
                CREATE TABLE IF NOT EXISTS generated_reports (
                    id TEXT PRIMARY KEY,
                    template_id TEXT,
                    title TEXT,
                    content TEXT,
                    format TEXT,
                    generated_at TEXT,
                    file_path TEXT,
                    recipients TEXT
                )
            """)
            
            conn.execute("""
                CREATE TABLE IF NOT EXISTS dashboard_widgets (
                    id TEXT PRIMARY KEY,
                    title TEXT,
                    type TEXT,
                    data_source TEXT,
                    config TEXT,
                    position TEXT,
                    refresh_interval INTEGER
                )
            """)
            
            conn.commit()
            conn.close()
            
            self.logger.info("✅ AI reporting database initialized")
            
        except Exception as e:
            self.logger.error(f"Database initialization failed: {e}")
    
    def _load_default_templates(self):
        """Load default report templates"""
        try:
            # Executive Dashboard Template
            executive_template = ReportTemplate(
                id="executive_dashboard",
                name="Executive Dashboard Report",
                description="High-level business metrics and KPIs for executives",
                sections=[
                    "executive_summary",
                    "key_metrics",
                    "performance_trends", 
                    "critical_issues",
                    "strategic_recommendations"
                ],
                data_sources=["business_metrics", "user_analytics"],
                analysis_types=["descriptive", "predictive", "prescriptive"],
                format=ReportFormat.HTML,
                frequency=ReportFrequency.DAILY,
                recipients=["ceo@example.com", "cto@example.com"],
                created_at=datetime.now().isoformat()
            )
            
            # Technical Performance Template
            technical_template = ReportTemplate(
                id="technical_performance",
                name="Technical Performance Report",
                description="System performance metrics and technical insights",
                sections=[
                    "performance_overview",
                    "system_health",
                    "anomaly_detection",
                    "optimization_recommendations",
                    "capacity_planning"
                ],
                data_sources=["app_performance"],
                analysis_types=["descriptive", "diagnostic", "predictive"],
                format=ReportFormat.HTML,
                frequency=ReportFrequency.HOURLY,
                recipients=["dev-team@example.com", "ops-team@example.com"],
                created_at=datetime.now().isoformat()
            )
            
            # Business Intelligence Template
            bi_template = ReportTemplate(
                id="business_intelligence",
                name="Business Intelligence Report",
                description="Comprehensive business analysis and insights",
                sections=[
                    "market_analysis",
                    "customer_insights",
                    "revenue_analysis",
                    "growth_opportunities",
                    "competitive_analysis"
                ],
                data_sources=["business_metrics", "user_analytics"],
                analysis_types=["descriptive", "diagnostic", "predictive", "prescriptive"],
                format=ReportFormat.PDF,
                frequency=ReportFrequency.WEEKLY,
                recipients=["business-team@example.com"],
                created_at=datetime.now().isoformat()
            )
            
            self.templates = {
                "executive_dashboard": executive_template,
                "technical_performance": technical_template,
                "business_intelligence": bi_template
            }
            
            self.logger.info("✅ Default report templates loaded")
            
        except Exception as e:
            self.logger.error(f"Failed to load default templates: {e}")
    
    def _initialize_report_engine(self):
        """Initialize the report generation engine"""
        try:
            # Create output directories
            self.output_dir = Path("generated_reports")
            self.output_dir.mkdir(exist_ok=True)
            
            # Initialize template engine if available
            if JINJA2_AVAILABLE:
                self.template_env = jinja2.Environment(
                    loader=jinja2.DictLoader({}),
                    autoescape=jinja2.select_autoescape(['html', 'xml'])
                )
            
            self.logger.info("✅ Report generation engine initialized")
            
        except Exception as e:
            self.logger.error(f"Report engine initialization failed: {e}")
    
    async def create_report_template(self, template: ReportTemplate) -> bool:
        """Create a new report template"""
        try:
            self.templates[template.id] = template
            
            # Save to database
            conn = sqlite3.connect(self.db_path)
            conn.execute("""
                INSERT OR REPLACE INTO report_templates 
                (id, name, description, sections, data_sources, analysis_types, 
                 format, frequency, recipients, created_at, active)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                template.id, template.name, template.description,
                json.dumps(template.sections), json.dumps(template.data_sources),
                json.dumps(template.analysis_types), template.format.value,
                template.frequency.value, json.dumps(template.recipients),
                template.created_at, template.active
            ))
            conn.commit()
            conn.close()
            
            self.logger.info(f"✅ Created report template: {template.name}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to create template: {e}")
            return False
    
    async def schedule_report(self, schedule: ReportSchedule) -> bool:
        """Schedule a report for automatic generation"""
        try:
            self.schedules[schedule.id] = schedule
            
            # Save to database
            conn = sqlite3.connect(self.db_path)
            conn.execute("""
                INSERT OR REPLACE INTO report_schedules 
                (id, template_id, frequency, next_run, last_run, 
                 recipients, delivery_methods, active)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                schedule.id, schedule.template_id, schedule.frequency.value,
                schedule.next_run, schedule.last_run,
                json.dumps(schedule.recipients), json.dumps(schedule.delivery_methods),
                schedule.active
            ))
            conn.commit()
            conn.close()
            
            self.logger.info(f"✅ Scheduled report: {schedule.id}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to schedule report: {e}")
            return False
    
    async def generate_report(self, template_id: str, custom_params: Optional[Dict] = None) -> Optional[Report]:
        """Generate a report using specified template"""
        try:
            if template_id not in self.templates:
                self.logger.error(f"Template {template_id} not found")
                return None
            
            template = self.templates[template_id]
            
            print(f"📊 Generating report: {template.name}")
            
            # Generate insights from data sources
            all_insights = []
            for source_id in template.data_sources:
                for analysis_type_str in template.analysis_types:
                    try:
                        from data_intelligence_orchestrator import AnalysisType
                        analysis_type = AnalysisType(analysis_type_str)
                        insights = await data_intelligence.analyze_data(source_id, analysis_type)
                        all_insights.extend(insights)
                    except Exception as e:
                        self.logger.warning(f"Analysis failed for {source_id}: {e}")
            
            # Generate executive summary
            executive_summary = await self._generate_executive_summary(all_insights)
            
            # Create report content
            report_content = await self._generate_report_content(template, all_insights, executive_summary)
            
            # Generate visualizations
            visualizations = await self._generate_report_visualizations(template.data_sources)
            
            # Create report object
            report = Report(
                id=f"{template_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                title=template.name,
                description=template.description,
                data_sources=template.data_sources,
                insights=[insight.id for insight in all_insights],
                visualizations=visualizations,
                created_at=datetime.now().isoformat(),
                created_by="AI Reporting Agent",
                format=template.format.value
            )
            
            # Save report content to file
            output_file = await self._save_report(report, report_content, template.format)
            
            # Store in database
            self.generated_reports[report.id] = report
            
            self.logger.info(f"✅ Generated report: {report.title}")
            return report
            
        except Exception as e:
            self.logger.error(f"Report generation failed: {e}")
            return None
    
    async def _generate_executive_summary(self, insights: List[DataInsight]) -> ExecutiveSummary:
        """Generate AI-powered executive summary"""
        try:
            # Categorize insights by priority and type
            critical_issues = []
            key_findings = []
            recommendations = []
            
            for insight in insights:
                if insight.priority == "high":
                    critical_issues.append(insight.title)
                
                key_findings.append(f"{insight.title}: {insight.description}")
                recommendations.extend(insight.recommendations[:2])  # Top 2 recommendations
            
            # Calculate overall confidence
            avg_confidence = np.mean([insight.confidence for insight in insights]) if insights else 0.5
            
            # Generate business impact assessment
            business_impact = self._assess_business_impact(insights)
            
            summary = ExecutiveSummary(
                title="AI-Generated Executive Summary",
                key_findings=key_findings[:5],  # Top 5 findings
                critical_issues=critical_issues[:3],  # Top 3 critical issues
                recommendations=list(set(recommendations))[:5],  # Top 5 unique recommendations
                business_impact=business_impact,
                confidence_score=avg_confidence,
                generated_at=datetime.now().isoformat()
            )
            
            return summary
            
        except Exception as e:
            self.logger.error(f"Executive summary generation failed: {e}")
            return ExecutiveSummary(
                title="Executive Summary",
                key_findings=["Analysis completed"],
                critical_issues=[],
                recommendations=["Continue monitoring"],
                business_impact="Monitoring required",
                confidence_score=0.5,
                generated_at=datetime.now().isoformat()
            )
    
    def _assess_business_impact(self, insights: List[DataInsight]) -> str:
        """Assess overall business impact from insights"""
        try:
            high_priority_count = sum(1 for insight in insights if insight.priority == "high")
            total_insights = len(insights)
            
            if high_priority_count == 0:
                return "Low impact - System operating within normal parameters"
            elif high_priority_count / total_insights < 0.3:
                return "Medium impact - Some areas require attention"
            else:
                return "High impact - Immediate action recommended"
                
        except Exception as e:
            return "Impact assessment unavailable"
    
    async def _generate_report_content(self, template: ReportTemplate, 
                                     insights: List[DataInsight], 
                                     executive_summary: ExecutiveSummary) -> str:
        """Generate report content based on template"""
        try:
            content_sections = []
            
            # Add executive summary section
            if "executive_summary" in template.sections:
                content_sections.append(f"""
## Executive Summary

**{executive_summary.title}**

### Key Findings
{chr(10).join([f"• {finding}" for finding in executive_summary.key_findings])}

### Critical Issues
{chr(10).join([f"🚨 {issue}" for issue in executive_summary.critical_issues]) if executive_summary.critical_issues else "No critical issues identified"}

### Strategic Recommendations
{chr(10).join([f"💡 {rec}" for rec in executive_summary.recommendations])}

**Business Impact:** {executive_summary.business_impact}
**Confidence Score:** {executive_summary.confidence_score:.1%}
""")
            
            # Add insights sections
            if "key_metrics" in template.sections:
                metrics_insights = [i for i in insights if i.analysis_type.value == "descriptive"]
                if metrics_insights:
                    content_sections.append(f"""
## Key Metrics Overview

{chr(10).join([f"### {insight.title}\n{insight.description}\n**Confidence:** {insight.confidence:.1%}" for insight in metrics_insights[:5]])}
""")
            
            # Add performance analysis
            if "performance_trends" in template.sections or "performance_overview" in template.sections:
                performance_insights = [i for i in insights if "performance" in i.title.lower() or "trend" in i.title.lower()]
                if performance_insights:
                    content_sections.append(f"""
## Performance Analysis

{chr(10).join([f"### {insight.title}\n{insight.description}\n" + chr(10).join([f"• {rec}" for rec in insight.recommendations[:3]]) for insight in performance_insights[:3]])}
""")
            
            # Add predictive insights
            if "capacity_planning" in template.sections or "growth_opportunities" in template.sections:
                predictive_insights = [i for i in insights if i.analysis_type.value == "predictive"]
                if predictive_insights:
                    content_sections.append(f"""
## Predictive Analysis

{chr(10).join([f"### {insight.title}\n{insight.description}\n**Key Metrics:** {', '.join([f'{k}: {v}' for k, v in list(insight.metrics.items())[:3]])}" for insight in predictive_insights[:3]])}
""")
            
            # Add optimization recommendations
            if "optimization_recommendations" in template.sections or "strategic_recommendations" in template.sections:
                prescriptive_insights = [i for i in insights if i.analysis_type.value == "prescriptive"]
                if prescriptive_insights:
                    content_sections.append(f"""
## Optimization Recommendations

{chr(10).join([f"### {insight.title}\n{insight.description}\n#### Recommended Actions:\n" + chr(10).join([f"1. {rec}" for rec in insight.recommendations[:5]]) for insight in prescriptive_insights[:3]])}
""")
            
            # Combine all sections
            full_content = f"""
# {template.name}

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Data Sources:** {', '.join(template.data_sources)}
**Analysis Types:** {', '.join(template.analysis_types)}

---

{chr(10).join(content_sections)}

---

## Report Details

**Total Insights Generated:** {len(insights)}
**Analysis Coverage:** {len(template.data_sources)} data sources
**Generated by:** AI Reporting Agent
**Next Update:** {(datetime.now() + timedelta(hours=24)).strftime('%Y-%m-%d %H:%M:%S')}
"""
            
            return full_content
            
        except Exception as e:
            self.logger.error(f"Content generation failed: {e}")
            return f"# {template.name}\n\nReport generation encountered an error: {e}"
    
    async def _generate_report_visualizations(self, data_sources: List[str]) -> List[Dict]:
        """Generate visualizations for the report"""
        visualizations = []
        
        try:
            for source_id in data_sources:
                # Get visualizations from data intelligence platform
                source_viz = await data_intelligence._generate_visualizations(source_id)
                visualizations.extend(source_viz)
            
            return visualizations[:10]  # Limit to 10 visualizations
            
        except Exception as e:
            self.logger.error(f"Visualization generation failed: {e}")
            return []
    
    async def _save_report(self, report: Report, content: str, format: ReportFormat) -> str:
        """Save report to file"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"{report.title.replace(' ', '_')}_{timestamp}"
            
            if format == ReportFormat.HTML:
                # Convert markdown to HTML
                html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>{report.title}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        h1 {{ color: #2c3e50; }}
        h2 {{ color: #34495e; border-bottom: 2px solid #ecf0f1; }}
        .metric {{ background: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 5px; }}
        .recommendation {{ background: #e8f5e8; padding: 10px; margin: 10px 0; border-radius: 5px; }}
        .critical {{ background: #ffeaa7; padding: 10px; margin: 10px 0; border-radius: 5px; }}
    </style>
</head>
<body>
{content.replace(chr(10), '<br>').replace('##', '<h2>').replace('###', '<h3>').replace('**', '<strong>').replace('• ', '<li>').replace('🚨', '<span style="color: red;">🚨</span>').replace('💡', '<span style="color: green;">💡</span>')}
</body>
</html>
"""
                file_path = self.output_dir / f"{filename}.html"
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(html_content)
            
            elif format == ReportFormat.MARKDOWN:
                file_path = self.output_dir / f"{filename}.md"
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            
            elif format == ReportFormat.JSON:
                json_content = {
                    "report": asdict(report),
                    "content": content,
                    "generated_at": datetime.now().isoformat()
                }
                file_path = self.output_dir / f"{filename}.json"
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(json_content, f, indent=2)
            
            else:
                # Default to text
                file_path = self.output_dir / f"{filename}.txt"
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            
            self.logger.info(f"✅ Report saved to: {file_path}")
            return str(file_path)
            
        except Exception as e:
            self.logger.error(f"Failed to save report: {e}")
            return ""
    
    async def create_dashboard(self, dashboard_id: str, widgets: List[DashboardWidget]) -> bool:
        """Create an interactive dashboard"""
        try:
            # Store widgets
            for widget in widgets:
                self.dashboard_widgets[widget.id] = widget
                
                # Save to database
                conn = sqlite3.connect(self.db_path)
                conn.execute("""
                    INSERT OR REPLACE INTO dashboard_widgets 
                    (id, title, type, data_source, config, position, refresh_interval)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (
                    widget.id, widget.title, widget.type, widget.data_source,
                    json.dumps(widget.config), json.dumps(widget.position),
                    widget.refresh_interval
                ))
                conn.commit()
                conn.close()
            
            # Generate dashboard HTML
            dashboard_html = await self._generate_dashboard_html(dashboard_id, widgets)
            
            # Save dashboard
            dashboard_file = self.output_dir / f"dashboard_{dashboard_id}.html"
            with open(dashboard_file, 'w', encoding='utf-8') as f:
                f.write(dashboard_html)
            
            self.logger.info(f"✅ Created dashboard: {dashboard_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"Dashboard creation failed: {e}")
            return False
    
    async def _generate_dashboard_html(self, dashboard_id: str, widgets: List[DashboardWidget]) -> str:
        """Generate interactive dashboard HTML"""
        try:
            widget_html = []
            
            for widget in widgets:
                if widget.type == "metric":
                    # Get latest metric value
                    data = await data_intelligence.load_data(widget.data_source)
                    if data is not None and not data.empty:
                        metric_value = data.iloc[-1].to_dict() if len(data) > 0 else {}
                        widget_html.append(f"""
                        <div class="widget metric-widget" style="grid-column: {widget.position['x']}; grid-row: {widget.position['y']};">
                            <h3>{widget.title}</h3>
                            <div class="metric-value">{metric_value}</div>
                        </div>
                        """)
                
                elif widget.type == "chart":
                    widget_html.append(f"""
                    <div class="widget chart-widget" style="grid-column: {widget.position['x']}; grid-row: {widget.position['y']};">
                        <h3>{widget.title}</h3>
                        <div id="chart_{widget.id}">Loading chart...</div>
                        <script>
                            // Chart will be rendered here with real data
                            document.getElementById('chart_{widget.id}').innerHTML = 'Interactive chart for {widget.data_source}';
                        </script>
                    </div>
                    """)
            
            dashboard_html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>AI Dashboard - {dashboard_id}</title>
    <style>
        body {{ 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: #f5f6fa;
        }}
        .dashboard-container {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }}
        .widget {{
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }}
        .widget:hover {{
            transform: translateY(-2px);
        }}
        .metric-widget {{
            text-align: center;
        }}
        .metric-value {{
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
            margin: 10px 0;
        }}
        h1 {{
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }}
        h3 {{
            color: #34495e;
            margin-top: 0;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }}
        .last-updated {{
            text-align: center;
            color: #7f8c8d;
            margin-top: 30px;
        }}
    </style>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
    <h1>🚀 AI Intelligence Dashboard - {dashboard_id}</h1>
    
    <div class="dashboard-container">
        {chr(10).join(widget_html)}
    </div>
    
    <div class="last-updated">
        Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
        <br>
        Auto-refresh: Every 30 seconds
    </div>
    
    <script>
        // Auto-refresh every 30 seconds
        setInterval(function() {{
            location.reload();
        }}, 30000);
        
        console.log('AI Dashboard loaded successfully! 🎉');
    </script>
</body>
</html>
"""
            
            return dashboard_html
            
        except Exception as e:
            self.logger.error(f"Dashboard HTML generation failed: {e}")
            return f"<html><body><h1>Dashboard Error</h1><p>{e}</p></body></html>"
    
    async def run_scheduled_reports(self) -> List[Report]:
        """Run all scheduled reports that are due"""
        generated_reports = []
        
        try:
            current_time = datetime.now()
            
            for schedule in self.schedules.values():
                if not schedule.active:
                    continue
                
                next_run_time = datetime.fromisoformat(schedule.next_run)
                
                if current_time >= next_run_time:
                    print(f"📊 Running scheduled report: {schedule.template_id}")
                    
                    # Generate report
                    report = await self.generate_report(schedule.template_id)
                    
                    if report:
                        generated_reports.append(report)
                        
                        # Update schedule
                        schedule.last_run = current_time.isoformat()
                        schedule.next_run = self._calculate_next_run(current_time, schedule.frequency).isoformat()
                        
                        # Send to recipients
                        await self._deliver_report(report, schedule.recipients, schedule.delivery_methods)
            
            return generated_reports
            
        except Exception as e:
            self.logger.error(f"Scheduled reports execution failed: {e}")
            return []
    
    def _calculate_next_run(self, current_time: datetime, frequency: ReportFrequency) -> datetime:
        """Calculate next run time based on frequency"""
        if frequency == ReportFrequency.HOURLY:
            return current_time + timedelta(hours=1)
        elif frequency == ReportFrequency.DAILY:
            return current_time + timedelta(days=1)
        elif frequency == ReportFrequency.WEEKLY:
            return current_time + timedelta(weeks=1)
        elif frequency == ReportFrequency.MONTHLY:
            return current_time + timedelta(days=30)
        elif frequency == ReportFrequency.QUARTERLY:
            return current_time + timedelta(days=90)
        else:
            return current_time + timedelta(hours=1)
    
    async def _deliver_report(self, report: Report, recipients: List[str], methods: List[str]) -> bool:
        """Deliver report to recipients"""
        try:
            # Simulate report delivery
            print(f"📧 Delivering report '{report.title}' to {len(recipients)} recipients")
            for recipient in recipients:
                print(f"   → {recipient}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Report delivery failed: {e}")
            return False
    
    def get_templates(self) -> List[ReportTemplate]:
        """Get all available report templates"""
        return list(self.templates.values())
    
    def get_schedules(self) -> List[ReportSchedule]:
        """Get all report schedules"""
        return list(self.schedules.values())
    
    def get_generated_reports(self) -> List[Report]:
        """Get all generated reports"""
        return list(self.generated_reports.values())
    
    async def get_reporting_status(self) -> Dict[str, Any]:
        """Get comprehensive reporting system status"""
        try:
            return {
                "system_status": "operational",
                "templates": {
                    "total": len(self.templates),
                    "active": sum(1 for t in self.templates.values() if t.active)
                },
                "schedules": {
                    "total": len(self.schedules),
                    "active": sum(1 for s in self.schedules.values() if s.active)
                },
                "reports": {
                    "total_generated": len(self.generated_reports),
                    "generated_today": len([r for r in self.generated_reports.values() 
                                          if datetime.fromisoformat(r.created_at).date() == datetime.now().date()])
                },
                "dashboards": {
                    "total_widgets": len(self.dashboard_widgets)
                },
                "last_updated": datetime.now().isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"Status retrieval failed: {e}")
            return {"error": str(e)}

# Global instance
ai_reporting = AIReportingOrchestrator()

# Example usage
async def demo_ai_reporting():
    """Demonstrate AI reporting capabilities"""
    
    print("📊 AI Reporting Platform Demo")
    print("=" * 50)
    
    # Show available templates
    templates = ai_reporting.get_templates()
    print(f"\n📋 Available Report Templates: {len(templates)}")
    for template in templates:
        print(f"   • {template.name} ({template.frequency.value})")
    
    # Generate executive dashboard report
    print(f"\n🚀 Generating Executive Dashboard Report...")
    exec_report = await ai_reporting.generate_report("executive_dashboard")
    
    if exec_report:
        print(f"✅ Executive report generated")
        print(f"   📊 {len(exec_report.insights)} insights included")
        print(f"   📈 {len(exec_report.visualizations)} visualizations created")
    
    # Generate technical performance report
    print(f"\n⚡ Generating Technical Performance Report...")
    tech_report = await ai_reporting.generate_report("technical_performance")
    
    if tech_report:
        print(f"✅ Technical report generated")
        print(f"   🔧 {len(tech_report.insights)} insights included")
    
    # Create sample dashboard
    print(f"\n📊 Creating Interactive Dashboard...")
    
    sample_widgets = [
        DashboardWidget(
            id="performance_metric",
            title="System Performance",
            type="metric",
            data_source="app_performance",
            config={"metric": "response_time"},
            position={"x": 1, "y": 1, "width": 1, "height": 1},
            refresh_interval=30
        ),
        DashboardWidget(
            id="business_chart",
            title="Business Metrics Trend",
            type="chart",
            data_source="business_metrics",
            config={"chart_type": "line", "metric": "revenue"},
            position={"x": 2, "y": 1, "width": 2, "height": 1},
            refresh_interval=60
        )
    ]
    
    dashboard_created = await ai_reporting.create_dashboard("main_dashboard", sample_widgets)
    
    if dashboard_created:
        print(f"✅ Interactive dashboard created")
        print(f"   📊 {len(sample_widgets)} widgets configured")
    
    # Show reporting status
    status = await ai_reporting.get_reporting_status()
    print(f"\n📈 Reporting System Status:")
    print(f"   Templates: {status['templates']['active']}/{status['templates']['total']} active")
    print(f"   Reports Generated: {status['reports']['total_generated']}")
    print(f"   Dashboard Widgets: {status['dashboards']['total_widgets']}")
    
    print(f"\n🎉 AI Reporting Platform is fully operational!")
    print("Ready to generate intelligent reports and dashboards! 📊✨")

if __name__ == "__main__":
    asyncio.run(demo_ai_reporting())
